/*
Copyright 2008 Flaptor (flaptor.com) 

Licensed under the Apache License, Version 2.0 (the "License"); 
you may not use this file except in compliance with the License. 
You may obtain a copy of the License at 

    http://www.apache.org/licenses/LICENSE-2.0 

Unless required by applicable law or agreed to in writing, software 
distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and 
limitations under the License.
*/
package com.flaptor.search4j;

/**
 * Describes how this index fits into the cluster of indexes.
 * Contains information about how many indexes make up the cluster, and about
 * what part of the documents this index contains.
 * 
 * @author Flaptor Development Team
 */
public final class IndexDescriptor implements java.io.Serializable{
	private int totalNumberOfNodes;
	private int nodeNumber;
	private String clusterName;

    private String rsyncAccessString; 
    private String localPath;



    public static IndexDescriptor defaultDescriptor() {
        return new IndexDescriptor(1,0,"defaultCluster");
    }
    
    /**
     * Gets a MultiDescriptor for the gives array of cluster names
     * @param clusterNames 
     * 			String[] with names of clusters for each index on a MultiIndex
     * @return
     * 			IndexDescriptor for the given String[] of clusterNames.
     */
    public static IndexDescriptor getMultiDescriptor(String[] clusterNames) {
    		StringBuffer sb = new StringBuffer();
    		for (String clusterName: clusterNames) {
    			sb.append(clusterName);
    			sb.append("-");
    		}
    		return new IndexDescriptor(-1,-1,sb.substring(0, sb.length()-1));
    }

	/**
	 * Constructor.
	 * @param totalNumberOfNodes the number of indexes (indexers) that make up
	 *	this cluste.
	 * @param nodeNumber the fragment of the whole corpus of document that this
	 *	index holds, 0 based.
	 * @param clusterName a text description of the cluster. Useful when different
	 *	clusters are running on the same machine(s).
	 * @throws IllegalArgumentException if totalNumberOfNodes &lt 1 or if
	 *	nodeNumber &lt 0 or &gt= totalNumberOfNodes.
	 */
	public IndexDescriptor(final int totalNumberOfNodes, final int nodeNumber, final String clusterName) {
		constructorHelper(totalNumberOfNodes, nodeNumber, clusterName);
	}

	private void constructorHelper(final int totalNumberOfNodes, final int nodeNumber, final String clusterName) {
		
		// If int parameters are -1 and clusterName contains "-", we are in presence of a multiindex.
		// validations make no sense, so skip them.
		if (!(-1 == totalNumberOfNodes && -1 == nodeNumber && clusterName.contains("-"))) {
		
			if ( totalNumberOfNodes < 1 ) {
				throw new IllegalArgumentException("No cluster can have less than 1 node. Received as paramer " + totalNumberOfNodes);
			}
			if ( (nodeNumber < 0 ) || (nodeNumber >= totalNumberOfNodes) ) {
				throw new IllegalArgumentException("Invalid nodeNumber ( " + nodeNumber + "). Must be between 0 and totalNumberOfNodes.");
			}
			if (null == clusterName) {
				throw new IllegalArgumentException("ClusterName cannot be null.");
			}
		}
		this.totalNumberOfNodes = totalNumberOfNodes;
		this.nodeNumber = nodeNumber;
		this.clusterName = clusterName;
	}

	/**
	 * Constructor.
	 * Parses the string as [number]of[number]@[clusterName]. For example:
	 *	0of2@myCluster describes the index 0 of a cluster named myCluster
	 *	of 2 nodes. (this is the same string generated by toString()
	 */
	public IndexDescriptor(final String line) {
        if (null == line) {
            throw new IllegalArgumentException("the line parameter cannot be null.");
        }
		String[] array1 = line.split("@");
		if (array1.length != 2) {
			throw new IllegalArgumentException("Malformed string.");
		}
		String clusterName = array1[1];
		String[] array2 = array1[0].split("of");
		if (array2.length !=2) {
			throw new IllegalArgumentException("Malformed string.");
		}
		int nodeNumber;
		try {
			nodeNumber = Integer.parseInt(array2[0]);
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("Malformed string");
		}
		int totalNumberOfNodes;
		try {
			totalNumberOfNodes = Integer.parseInt(array2[1]);
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("MarformedString");
		}
		constructorHelper(totalNumberOfNodes, nodeNumber, clusterName);
	}

	/**
	 * Returns the fragment this node represents.
	 * @return the fragment of the whole corpus of documents this index holds, 0 based.
	 */
	public int getNodeNumber() {
		return nodeNumber;
	}

	/**
	 * Returns the total number of nodes in this cluster.
	 * If this is a standalone indexer, the cluster has size 1.
	 */
	 public int getTotalNumberOfNodes() {
	 	return totalNumberOfNodes;
	}

	/**
	 * Returns the name of the cluster this node belongs to.
	 */
	public String getClusterName() {
		return clusterName;
	}



    public void setRsyncAccessString(String access){
        this.rsyncAccessString = access;
    }
    public String getRsyncAccessString() {
        return rsyncAccessString;
    }

    public void setLocalPath(String path) {
        this.localPath = path;
    }
    public String getLocalPath() {
        return localPath;
    }

    public String getRemotePath() {
        String retValue = "";
        if (null != rsyncAccessString && !"".equals(rsyncAccessString)) {
            retValue = rsyncAccessString + ":";
        }
        return retValue + this.localPath;
    }




	@Override
	public String toString() {
		return String.valueOf(getNodeNumber()) + "of" + getTotalNumberOfNodes() + "@" + getClusterName();
	}
    
    @Override
    public boolean equals(Object o) {
        if (this.getClass().equals(o)) {
            return false;
        }
        IndexDescriptor id = (IndexDescriptor) o;
        return (clusterName.equals(id.clusterName)) && (totalNumberOfNodes == id.totalNumberOfNodes) && (nodeNumber == id.nodeNumber);
    }
    
    @Override
    public int hashCode() {
        return clusterName.hashCode() ^ totalNumberOfNodes ^ nodeNumber;
    }
}
